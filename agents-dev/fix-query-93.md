# Task 93:

Put the below query into python functional tests. And run it. The test will give an error. 

Try to find ways to fix that error. Document your changes, what you have tried in this file. 

Don't change the query ! We can't change the incoming queries. You can rewrite as the other rewrite filters.

For this very task, it's ok if the test fails. Just document what you tried ! 

input sql "SELECT\n  attname AS name,\n  attnum AS OID,\n  typ.oid AS typoid,\n  typ.typname AS datatype,\n  attnotnull AS not_null,\n  attr.atthasdef AS has_default_val,\n  nspname,\n  relname,\n  attrelid,\n  CASE WHEN typ.typtype = 'd' THEN typ.typtypmod ELSE atttypmod END AS typmod,\n  CASE WHEN atthasdef THEN (SELECT pg_get_expr(adbin, cls.oid) FROM pg_attrdef WHERE adrelid = cls.oid AND adnum = attr.attnum) ELSE NULL END AS default,\n  TRUE AS is_updatable, /* Supported only since PG 8.2 */\n  \n  CASE WHEN EXISTS (SELECT * FROM information_schema.key_column_usage WHERE table_schema = nspname AND table_name = relname AND column_name = attname) THEN TRUE ELSE FALSE END AS isprimarykey,\n  CASE WHEN EXISTS (SELECT * FROM information_schema.table_constraints WHERE table_schema = nspname AND table_name = relname AND constraint_type = 'UNIQUE' AND constraint_name IN (SELECT constraint_name FROM information_schema.constraint_column_usage WHERE table_schema = nspname AND table_name = relname AND column_name = attname)) THEN TRUE ELSE FALSE END AS isunique \nFROM pg_attribute AS attr\nJOIN pg_type AS typ ON attr.atttypid = typ.oid\nJOIN pg_class AS cls ON cls.oid = attr.attrelid\nJOIN pg_namespace AS ns ON ns.oid = cls.relnamespace\nLEFT OUTER JOIN information_schema.columns AS col ON col.table_schema = nspname AND\n col.table_name = relname AND\n col.column_name = attname\nWHERE\n attr.attrelid = 50010::oid\n    AND attr.attnum > 0\n  AND atttypid <> 0 AND\n relkind IN ('r', 'v', 'm', 'p') AND\n NOT attisdropped \nORDER BY attnum\n;"
result: "SELECT attname AS name, attnum AS OID, typ.oid AS typoid, typ.typname AS datatype, attnotnull AS not_null, attr.atthasdef AS has_default_val, nspname AS alias_1, relname AS alias_2, attrelid AS alias_3, CASE WHEN typ.typtype = 'd' THEN typ.typtypmod ELSE atttypmod END AS typmod, CASE WHEN atthasdef THEN (SELECT pg_get_expr(adbin, cls.oid) FROM pg_attrdef AS subq0_t WHERE adrelid = cls.oid AND adnum = attr.attnum) ELSE NULL END AS default, true AS is_updatable, CASE WHEN EXISTS (SELECT * FROM information_schema.key_column_usage WHERE table_schema = nspname AND table_name = relname AND column_name = attname) THEN true ELSE false END AS isprimarykey, CASE WHEN EXISTS (SELECT * FROM information_schema.table_constraints WHERE table_schema = nspname AND table_name = relname AND constraint_type = 'UNIQUE' AND constraint_name IN (SELECT constraint_name FROM information_schema.constraint_column_usage WHERE table_schema = nspname AND table_name = relname AND column_name = attname)) THEN true ELSE false END AS isunique FROM pg_attribute AS attr JOIN pg_type AS typ ON attr.atttypid = typ.oid JOIN pg_class AS cls ON cls.oid = attr.attrelid JOIN pg_namespace AS ns ON ns.oid = cls.relnamespace LEFT OUTER JOIN information_schema.columns AS col ON col.table_schema = nspname AND col.table_name = relname AND col.column_name = attname WHERE attr.attrelid = 50010::BIGINT AND attr.attnum > 0 AND atttypid <> 0 AND relkind IN ('r', 'v', 'm', 'p') AND NOT attisdropped ORDER BY attnum" alias_map: {"alias_2": "relname", "alias_1": "nspname", "alias_3": "attrelid"}
before group by WITH __cte1 AS (SELECT pg_get_expr(adbin, adrelid) AS col, adnum, adrelid FROM pg_attrdef AS subq0_t) SELECT attname AS name, attnum AS OID, typ.oid AS typoid, typ.typname AS datatype, attnotnull AS not_null, attr.atthasdef AS has_default_val, nspname AS alias_1, relname AS alias_2, attrelid AS alias_3, CASE WHEN typ.typtype = 'd' THEN typ.typtypmod ELSE atttypmod END AS typmod, CASE WHEN atthasdef THEN __cte1.col ELSE NULL END AS default, true AS is_updatable, CASE WHEN EXISTS (SELECT * FROM information_schema.key_column_usage WHERE table_schema = nspname AND table_name = relname AND column_name = attname) THEN true ELSE false END AS isprimarykey, CASE WHEN EXISTS (SELECT * FROM information_schema.table_constraints WHERE table_schema = nspname AND table_name = relname AND constraint_type = 'UNIQUE' AND constraint_name IN (SELECT constraint_name FROM information_schema.constraint_column_usage WHERE table_schema = nspname AND table_name = relname AND column_name = attname)) THEN true ELSE false END AS isunique FROM pg_attribute AS attr JOIN pg_type AS typ ON attr.atttypid = typ.oid JOIN pg_class AS cls ON cls.oid = attr.attrelid JOIN pg_namespace AS ns ON ns.oid = cls.relnamespace LEFT OUTER JOIN information_schema.columns AS col ON col.table_schema = nspname AND col.table_name = relname AND col.column_name = attname LEFT OUTER JOIN __cte1 ON attr.attnum = __cte1.adnum AND cls.oid = __cte1.adrelid WHERE attr.attrelid = 50010::BIGINT AND attr.attnum > 0 AND atttypid <> 0 AND relkind IN ('r', 'v', 'm', 'p') AND NOT attisdropped ORDER BY attnum
final sql "WITH __cte1 AS (SELECT pg_get_expr(adbin, adrelid) AS col, adnum, adrelid FROM pg_attrdef AS subq0_t) SELECT attname AS name, attnum AS OID, typ.oid AS typoid, typ.typname AS datatype, attnotnull AS not_null, attr.atthasdef AS has_default_val, nspname AS alias_1, relname AS alias_2, attrelid AS alias_3, CASE WHEN typ.typtype = 'd' THEN typ.typtypmod ELSE atttypmod END AS typmod, CASE WHEN atthasdef THEN __cte1.col ELSE NULL END AS default, true AS is_updatable, CASE WHEN EXISTS (SELECT * FROM information_schema.key_column_usage WHERE table_schema = nspname AND table_name = relname AND column_name = attname) THEN true ELSE false END AS isprimarykey, CASE WHEN EXISTS (SELECT * FROM information_schema.table_constraints WHERE table_schema = nspname AND table_name = relname AND constraint_type = 'UNIQUE' AND constraint_name IN (SELECT constraint_name FROM information_schema.constraint_column_usage WHERE table_schema = nspname AND table_name = relname AND column_name = attname)) THEN true ELSE false END AS isunique FROM pg_attribute AS attr JOIN pg_type AS typ ON attr.atttypid = typ.oid JOIN pg_class AS cls ON cls.oid = attr.attrelid JOIN pg_namespace AS ns ON ns.oid = cls.relnamespace LEFT OUTER JOIN information_schema.columns AS col ON col.table_schema = nspname AND col.table_name = relname AND col.column_name = attname LEFT OUTER JOIN __cte1 ON attr.attnum = __cte1.adnum AND cls.oid = __cte1.adrelid WHERE attr.attrelid = 50010::BIGINT AND attr.attnum > 0 AND atttypid <> 0 AND relkind IN ('r', 'v', 'm', 'p') AND NOT attisdropped ORDER BY attnum"
exec_error query: "SELECT\n  attname AS name,\n  attnum AS OID,\n  typ.oid AS typoid,\n  typ.typname AS datatype,\n  attnotnull AS not_null,\n  attr.atthasdef AS has_default_val,\n  nspname,\n  relname,\n  attrelid,\n  CASE WHEN typ.typtype = 'd' THEN typ.typtypmod ELSE atttypmod END AS typmod,\n  CASE WHEN atthasdef THEN (SELECT pg_get_expr(adbin, cls.oid) FROM pg_attrdef WHERE adrelid = cls.oid AND adnum = attr.attnum) ELSE NULL END AS default,\n  TRUE AS is_updatable, /* Supported only since PG 8.2 */\n  \n  CASE WHEN EXISTS (SELECT * FROM information_schema.key_column_usage WHERE table_schema = nspname AND table_name = relname AND column_name = attname) THEN TRUE ELSE FALSE END AS isprimarykey,\n  CASE WHEN EXISTS (SELECT * FROM information_schema.table_constraints WHERE table_schema = nspname AND table_name = relname AND constraint_type = 'UNIQUE' AND constraint_name IN (SELECT constraint_name FROM information_schema.constraint_column_usage WHERE table_schema = nspname AND table_name = relname AND column_name = attname)) THEN TRUE ELSE FALSE END AS isunique \nFROM pg_attribute AS attr\nJOIN pg_type AS typ ON attr.atttypid = typ.oid\nJOIN pg_class AS cls ON cls.oid = attr.attrelid\nJOIN pg_namespace AS ns ON ns.oid = cls.relnamespace\nLEFT OUTER JOIN information_schema.columns AS col ON col.table_schema = nspname AND\n col.table_name = relname AND\n col.column_name = attname\nWHERE\n attr.attrelid = 50010::oid\n    AND attr.attnum > 0\n  AND atttypid <> 0 AND\n relkind IN ('r', 'v', 'm', 'p') AND\n NOT attisdropped \nORDER BY attnum\n;"
exec_error params: None
exec_error error: Diagnostic(Diagnostic { kind: Error, message: "column 'nspname' not found", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: None, name: "nspname" }, valid_fields: [Column { relation: Some(Partial { schema: "information_schema", table: "constraint_column_usage" }), name: "column_name" }, Column { relation: Some(Partial { schema: "information_schema", table: "constraint_column_usage" }), name: "constraint_catalog" }, Column { relation: Some(Partial { schema: "information_schema", table: "constraint_column_usage" }), name: "constraint_name" }, Column { relation: Some(Partial { schema: "information_schema", table: "constraint_column_usage" }), name: "constraint_schema" }, Column { relation: Some(Partial { schema: "information_schema", table: "constraint_column_usage" }), name: "table_catalog" }, Column { relation: Some(Partial { schema: "information_schema", table: "constraint_column_usage" }), name: "table_name" }, Column { relation: Some(Partial { schema: "information_schema", table: "constraint_column_usage" }), name: "table_schema" }] }, Some("")))