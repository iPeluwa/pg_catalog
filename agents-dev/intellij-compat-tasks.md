# Task 41:
exec_error query: "with schema_procs as (select prorettype, proargtypes, proallargtypes\n                      from pg_catalog.pg_proc\n                      where pronamespace = $1::oid\n                        and pg_catalog.age(xmin) <= coalesce(nullif(greatest(pg_catalog.age($2::varchar::xid), -1), -1), 2147483647)  ),\n     schema_opers as (select oprleft, oprright, oprresult\n                      from pg_catalog.pg_operator\n                      where oprnamespace = $3::oid\n                        and pg_catalog.age(xmin) <= coalesce(nullif(greatest(pg_catalog.age($4::varchar::xid), -1), -1), 2147483647)  ),\n     schema_aggregates as (select A.aggtranstype , A.aggmtranstype \n                           from pg_catalog.pg_aggregate A\n                           join pg_catalog.pg_proc P\n                             on A.aggfnoid = P.oid\n                           where P.pronamespace = $5::oid\n                           and (pg_catalog.age(A.xmin) <= coalesce(nullif(greatest(pg_catalog.age($6::varchar::xid), -1), -1), 2147483647) or pg_catalog.age(P.xmin) <= coalesce(nullif(greatest(pg_catalog.age($7::varchar::xid), -1), -1), 2147483647)) ),\n     schema_arg_types as ( select prorettype as type_id\n                           from schema_procs\n                           union\n                           select distinct unnest(proargtypes) as type_id\n                           from schema_procs\n                           union\n                           select distinct unnest(proallargtypes) as type_id\n                           from schema_procs\n                           union\n                           select oprleft as type_id\n                           from schema_opers\n                           where oprleft is not null\n                           union\n                           select oprright as type_id\n                           from schema_opers\n                           where oprright is not null\n                           union\n                           select oprresult as type_id\n                           from schema_opers\n                           where oprresult is not null\n                           union\n                           select aggtranstype::oid as type_id\n                           from schema_aggregates\n                           union\n                           select aggmtranstype::oid as type_id\n                           from schema_aggregates\n                           \n                           )\nselect type_id, pg_catalog.format_type(type_id, null) as type_spec\nfrom schema_arg_types\nwhere type_id <> 0 -- todo unclear how to frag"
exec_error params: Some([Some(b"\0\0\0\0\0\0\x08\x98"), Some(b"\0\0\0\0\0\0\0\0"), Some(b"\0\0\0\0\0\0\x08\x98"), Some(b"\0\0\0\0\0\0\0\0"), Some(b"\0\0\0\0\0\0\x08\x98"), Some(b"\0\0\0\0\0\0\0\0"), Some(b"\0\0\0\0\0\0\0\0")])
exec_error error: Plan("unnest() can only be applied to array, struct and null")
## # Task 41: Done
`proargtypes` is stored as text so `unnest()` failed. Added a rewrite that wraps
`unnest` arguments in `oidvector_to_array()` and implemented this UDF to parse
the string into a list of OIDs.
# Task 42:
exec_error query: "with T as ( select distinct\n                  T.oid as table_id, T.relname as table_name\n            from pg_catalog.pg_class T\n                 , pg_catalog.pg_attribute A\n            where T.relnamespace = $1::oid\n              and T.relkind in ('r', 'm', 'v', 'f', 'p')\n              and (pg_catalog.age(A.xmin) <= coalesce(nullif(greatest(pg_catalog.age($2::varchar::xid), -1), -1), 2147483647) or pg_catalog.age(T.xmin) <= coalesce(nullif(greatest(pg_catalog.age($3::varchar::xid), -1), -1), 2147483647))\n              and A.attrelid = T.oid\n             --  and T.relname in ( :[*f_names] )\n            )\nselect T.table_id,\n       C.attnum as column_position,\n       C.attname as column_name,\n       C.xmin as column_state_number,\n       C.atttypmod as type_mod,\n       C.attndims as dimensions_number,\n       pg_catalog.format_type(C.atttypid, C.atttypmod) as type_spec,\n       C.atttypid as type_id,\n       C.attnotnull as mandatory,\n       pg_catalog.pg_get_expr(D.adbin, T.table_id) /* D.adsrc */ as column_default_expression,\n       not C.attislocal as column_is_inherited,\n       C.attfdwoptions as options,\n       C.attisdropped as column_is_dropped,\n       C.attidentity /* null */ as identity_kind,\n       C.attgenerated /* null */ as generated\nfrom T\n  join pg_catalog.pg_attribute C on T.table_id = C.attrelid\n  left join pg_catalog.pg_attrdef D on (C.attrelid, C.attnum) = (D.adrelid, D.adnum)\nwhere attnum > 0\norder by table_id, attnum"
exec_error params: Some([Some(b"\0\0\0\0\0\0\x08\x98"), Some(b"\0\0\0\0\0\0\0\0"), Some(b"\0\0\0\0\0\0\0\0")])
exec_error error: NotImplemented("Only identifiers and literals are supported in tuples")
## # Task 42: Done
Tuple equality comparisons in join conditions were unsupported.
Implemented `rewrite_tuple_equality` to expand `(a,b) = (c,d)` into
`a = c AND b = d` and added tests verifying the behaviour.
# Task 43:
exec_error query: "select tab.oid               table_id,\n       tab.relkind           table_kind,\n       ind_stor.relname      index_name,\n       ind_head.indexrelid   index_id,\n       ind_stor.xmin         state_number,\n       ind_head.indisunique  is_unique,\n       ind_head.indisprimary is_primary,\n       /* ind_head.indnullsnotdistinct */false  nulls_not_distinct,\n       pg_catalog.pg_get_expr(ind_head.indpred, ind_head.indrelid) as condition,\n       (select pg_catalog.array_agg(inhparent::bigint order by inhseqno)::varchar from pg_catalog.pg_inherits where ind_stor.oid = inhrelid) as ancestors,\n       ind_stor.reltablespace tablespace_id,\n       opcmethod as access_method_id\nfrom pg_catalog.pg_class tab\n         join pg_catalog.pg_index ind_head\n              on ind_head.indrelid = tab.oid\n         join pg_catalog.pg_class ind_stor\n              on tab.relnamespace = ind_stor.relnamespace and ind_stor.oid = ind_head.indexrelid\n         left join pg_catalog.pg_opclass on pg_opclass.oid = ANY(indclass)\nwhere tab.relnamespace = $1::oid\n        and tab.relkind in ('r', 'm', 'v', 'p')\n        and ind_stor.relkind in ('i', 'I')\n--  and tab.relname in ( :[*f_names] )\nand pg_catalog.age(ind_stor.xmin) <= coalesce(nullif(greatest(pg_catalog.age($2::varchar::xid), -1), -1), 2147483647)"
exec_error params: Some([Some(b"\0\0\0\0\0\0\x08\x98"), Some(b"\0\0\0\0\0\0\0\0")])
exec_error error: Context("type_coercion", Plan("Failed to coerce arguments to satisfy a call to 'array_has' function: coercion from [Utf8, Int32] to the signature ArraySignature(Array { arguments: [Array, Element], array_coercion: Some(FixedSizedListToList) }) failed"))
# Task 44:
exec_error query: "select R.ev_class as table_id,\n       R.oid as rule_id,\n       R.xmin as rule_state_number,\n       R.rulename as rule_name,\n       pg_catalog.translate(ev_type,'1234','SUID') as rule_event_code,\n       R.ev_enabled as rule_fire_mode,\n       R.is_instead as rule_is_instead\nfrom pg_catalog.pg_rewrite R\nwhere R.ev_class in (\n  select oid\n  from pg_catalog.pg_class\n  where relnamespace = $1::oid\n--  and relname in ( :[*f_names] )\n)\n  and pg_catalog.age(R.xmin) <= coalesce(nullif(greatest(pg_catalog.age($2::varchar::xid), -1), -1), 2147483647)\n  and R.rulename != '_RETURN'::name\norder by R.ev_class::bigint, ev_type"
exec_error params: Some([Some(b"\0\0\0\0\0\0\x08\x98"), Some(b"\0\0\0\0\0\0\0\0")])
exec_error error: NotImplemented("Unsupported SQL type Custom(ObjectName([Identifier(Ident { value: \"name\", quote_style: None, span: Span(Location(1,499)..Location(1,503)) })]), [])")
## # Task 44: Done
Casting to the custom `name` type caused a parser error. Added `rewrite_name_cast` to
map such casts to TEXT and integrated it into the query rewrite pipeline.
Unit tests verify the rewrite and casting now succeeds.
# Task 45:
exec_error query: "select T.tgrelid as table_id,\n       T.oid as trigger_id,\n       T.xmin as trigger_state_number,\n       T.tgname as trigger_name,\n       T.tgfoid as function_id,\n       pg_catalog.encode(T.tgargs, 'escape') as function_args,\n       T.tgtype as bits,\n       T.tgdeferrable as is_deferrable,\n       T.tginitdeferred as is_init_deferred,\n       T.tgenabled as trigger_fire_mode,\n       T.tgattr as columns,\n       T.tgconstraint != 0 as is_constraint,\n       T.tgoldtable /* null */ as old_table_name,\n       T.tgnewtable /* null */ as new_table_name,\n       pg_catalog.pg_get_triggerdef(T.oid, true) as source_code\nfrom pg_catalog.pg_trigger T\njoin pg_catalog.pg_class TAB on TAB.oid = T.tgrelid and TAB.relnamespace = $1::oid\nwhere true\n  --  and TAB.relname in ( :[*f_names] )\n  and pg_catalog.age(T.xmin) <= coalesce(nullif(greatest(pg_catalog.age($2::varchar::xid), -1), -1), 21