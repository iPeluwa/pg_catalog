# Task 21:
exec_error query: "select T.relkind as table_kind,\n       T.relname as table_name,\n       T.oid as table_id,\n       T.xmin as table_state_number,\n       false /* T.relhasoids */ as table_with_oids,\n       T.reltablespace as tablespace_id,\n       T.reloptions as options,\n       T.relpersistence as persistence,\n       (select pg_catalog.array_agg(inhparent::bigint order by inhseqno)::varchar from pg_catalog.pg_inherits where T.oid = inhrelid) as ancestors,\n       (select pg_catalog.array_agg(inhrelid::bigint order by inhrelid)::varchar from pg_catalog.pg_inherits where T.oid = inhparent) as successors,\n       T.relispartition /* false */ as is_partition,\n       pg_catalog.pg_get_partkeydef(T.oid) /* null */ as partition_key,\n       pg_catalog.pg_get_expr(T.relpartbound, T.oid) /* null */ as partition_expression,\n       T.relam am_id,\n       pg_catalog.pg_get_userbyid(T.relowner) as \"owner\"\nfrom pg_catalog.pg_class T\nwhere relnamespace = $1::oid\n       and relkind in ('r', 'm', 'v', 'f', 'p')\n--  and pg_catalog.age(T.xmin) <= #TXAGE\n--  and T.relname in ( :[*f_names] )\norder by table_kind, table_id"
exec_error params: Some([Some(b"\0\0\0\0\0\0\x08\x98")])
exec_error error: Diagnostic(Diagnostic { kind: Error, message: "'pg_catalog.pg_inherits.inhrelid' must appear in GROUP BY clause because it's not an aggregate expression", span: None, notes: [], helps: [DiagnosticHelp { message: "Either add 'pg_catalog.pg_inherits.inhrelid' to GROUP BY clause, or use an aggregare function like ANY_VALUE(pg_catalog.pg_inherits.inhrelid)", span: None }] }, Plan("Column in SELECT must be in GROUP BY or an aggregate function: While expanding wildcard, column \"pg_catalog.pg_inherits.inhrelid\" must appear in the GROUP BY clause or must be part of an aggregate function, currently only \"array_agg(pg_catalog.pg_inherits.inhparent) ORDER BY [pg_catalog.pg_inherits.inhseqno ASC NULLS LAST]\" appears in the SELECT clause satisfies this requirement"))


# Task 22:
exec_error query: "with schema_procs as (select prorettype, proargtypes, proallargtypes\n                      from pg_catalog.pg_proc\n                      where pronamespace = $1::oid\n                        /* and pg_catalog.age(xmin) <= #TXAGE */ ),\n     schema_opers as (select oprleft, oprright, oprresult\n                      from pg_catalog.pg_operator\n                      where oprnamespace = $2::oid\n                        /* and pg_catalog.age(xmin) <= #TXAGE */ ),\n     schema_aggregates as (select A.aggtranstype , A.aggmtranstype \n                           from pg_catalog.pg_aggregate A\n                           join pg_catalog.pg_proc P\n                             on A.aggfnoid = P.oid\n                           where P.pronamespace = $3::oid\n                           /* and (pg_catalog.age(A.xmin) <= #TXAGE or pg_catalog.age(P.xmin) <= #TXAGE) */),\n     schema_arg_types as ( select prorettype as type_id\n                           from schema_procs\n                           union\n                           select distinct unnest(proargtypes) as type_id\n                           from schema_procs\n                           union\n                           select distinct unnest(proallargtypes) as type_id\n                           from schema_procs\n                           union\n                           select oprleft as type_id\n                           from schema_opers\n                           where oprleft is not null\n                           union\n                           select oprright as type_id\n                           from schema_opers\n                           where oprright is not null\n                           union\n                           select oprresult as type_id\n                           from schema_opers\n                           where oprresult is not null\n                           union\n                           select aggtranstype::oid as type_id\n                           from schema_aggregates\n                           union\n                           select aggmtranstype::oid as type_id\n                           from schema_aggregates\n                           \n                           )\nselect type_id, pg_catalog.format_type(type_id, null) as type_spec\nfrom schema_arg_types\nwhere type_id <> 0 -- todo unclear how to frag"
exec_error params: Some([Some(b"\0\0\0\0\0\0\x08\x98"), Some(b"\0\0\0\0\0\0\x08\x98"), Some(b"\0\0\0\0\0\0\x08\x98")])
exec_error error: Collection([Collection([Collection([Collection([Collection([Collection([Collection([Diagnostic(Diagnostic { kind: Error, message: "column 'prorettype' not found", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: None, name: "prorettype" }, valid_fields: [Column { relation: Some(Bare { table: "schema_procs" }), name: "alias_2" }, Column { relation: Some(Bare { table: "schema_procs" }), name: "alias_3" }, Column { relation: Some(Bare { table: "schema_procs" }), name: "alias_4" }] }, Some(""))), SchemaError(FieldNotFound { field: Column { relation: None, name: "proargtypes" }, valid_fields: [Column { relation: Some(Bare { table: "schema_procs" }), name: "alias_2" }, Column { relation: Some(Bare { table: "schema_procs" }), name: "alias_3" }, Column { relation: Some(Bare { table: "schema_procs" }), name: "alias_4" }] }, Some(""))]), SchemaError(FieldNotFound { field: Column { relation: None, name: "proallargtypes" }, valid_fields: [Column { relation: Some(Bare { table: "schema_procs" }), name: "alias_2" }, Column { relation: Some(Bare { table: "schema_procs" }), name: "alias_3" }, Column { relation: Some(Bare { table: "schema_procs" }), name: "alias_4" }] }, Some(""))]), Diagnostic(Diagnostic { kind: Error, message: "column 'oprleft' not found", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: None, name: "oprleft" }, valid_fields: [Column { relation: Some(Bare { table: "schema_opers" }), name: "alias_5" }, Column { relation: Some(Bare { table: "schema_opers" }), name: "alias_6" }, Column { relation: Some(Bare { table: "schema_opers" }), name: "alias_7" }] }, Some("")))]), Diagnostic(Diagnostic { kind: Error, message: "column 'oprright' not found", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: None, name: "oprright" }, valid_fields: [Column { relation: Some(Bare { table: "schema_opers" }), name: "alias_5" }, Column { relation: Some(Bare { table: "schema_opers" }), name: "alias_6" }, Column { relation: Some(Bare { table: "schema_opers" }), name: "alias_7" }] }, Some("")))]), Diagnostic(Diagnostic { kind: Error, message: "column 'oprresult' not found", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: None, name: "oprresult" }, valid_fields: [Column { relation: Some(Bare { table: "schema_opers" }), name: "alias_5" }, Column { relation: Some(Bare { table: "schema_opers" }), name: "alias_6" }, Column { relation: Some(Bare { table: "schema_opers" }), name: "alias_7" }] }, Some("")))]), Diagnostic(Diagnostic { kind: Error, message: "column 'aggtranstype' not found", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: None, name: "aggtranstype" }, valid_fields: [Column { relation: Some(Bare { table: "schema_aggregates" }), name: "alias_8" }, Column { relation: Some(Bare { table: "schema_aggregates" }), name: "alias_9" }] }, Some("")))]), Diagnostic(Diagnostic { kind: Error, message: "column 'aggmtranstype' not found", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: None, name: "aggmtranstype" }, valid_fields: [Column { relation: Some(Bare { table: "schema_aggregates" }), name: "alias_8" }, Column { relation: Some(Bare { table: "schema_aggregates" }), name: "alias_9" }] }, Some("")))])

# Task 23:
exec_error query: "select P.oid as aggregate_id,\n       P.xmin as state_number,\n       P.proname as aggregate_name,\n       P.proargnames as arg_names,\n       P.proargmodes as arg_modes,\n       P.proargtypes::int[] as in_arg_types,\n       P.proallargtypes::int[] as all_arg_types,\n       A.aggtransfn::oid as transition_function_id,\n       A.aggtransfn::regproc::text as transition_function_name,\n       A.aggtranstype as transition_type,\n       A.aggfinalfn::oid as final_function_id,\n       case when A.aggfinalfn::oid = 0 then null else A.aggfinalfn::regproc::varchar end as final_function_name,\n       case when A.aggfinalfn::oid = 0 then 0 else P.prorettype end as final_return_type,\n       A.agginitval as initial_value,\n       A.aggsortop as sort_operator_id,\n       case when A.aggsortop = 0 then null else A.aggsortop::regoper::varchar end as sort_operator_name,\n       pg_catalog.pg_get_userbyid(P.proowner) as \"owner\"\n       ,\n       A.aggfinalextra as final_extra,\n       A.aggtransspace as state_size,\n       A.aggmtransfn::oid as moving_transition_id,\n       case when A.aggmtransfn::oid = 0 then null else A.aggmtransfn::regproc::varchar end as moving_transition_name,\n       A.aggminvtransfn::oid as inverse_transition_id,\n       case when A.aggminvtransfn::oid = 0 then null else A.aggminvtransfn::regproc::varchar end as inverse_transition_name,\n       A.aggmtranstype::oid as moving_state_type,\n       A.aggmtransspace as moving_state_size,\n       A.aggmfinalfn::oid as moving_final_id,\n       case when A.aggmfinalfn::oid = 0 then null else A.aggmfinalfn::regproc::varchar end as moving_final_name,\n       A.aggmfinalextra as moving_final_extra,\n       A.aggminitval as moving_initial_value,\n       A.aggkind as aggregate_kind,\n       A.aggnumdirectargs as direct_args\n       \n       ,\n       A.aggcombinefn::oid as combine_function_id,\n       case when A.aggcombinefn::oid = 0 then null else A.aggcombinefn::regproc::varchar end as combine_function_name,\n       A.aggserialfn::oid as serialization_function_id,\n       case when A.aggserialfn::oid = 0 then null else A.aggserialfn::regproc::varchar end as serialization_function_name,\n       A.aggdeserialfn::oid as deserialization_function_id,\n       case when A.aggdeserialfn::oid = 0 then null else A.aggdeserialfn::regproc::varchar end as deserialization_function_name,\n       P.proparallel as concurrency_kind\n       \nfrom pg_catalog.pg_aggregate A\njoin pg_catalog.pg_proc P\n  on A.aggfnoid = P.oid\nwhere P.pronamespace = $1::oid\n--  and P.proname in ( :[*f_names] )\n--  and (pg_catalog.age(A.xmin) <= #TXAGE or pg_catalog.age(P.xmin) <= #TXAGE)\norder by P.oid"
exec_error params: Some([Some(b"\0\0\0\0\0\0\x08\x98")])
exec_error error: Collection([NotImplemented("Unsupported SQL type Custom(ObjectName([Identifier(Ident { value: \"regproc\", quote_style: None, span: Span(Location(1,279)..Location(1,286)) })]), [])"), NotImplemented("Unsupported SQL type Custom(ObjectName([Identifier(Ident { value: \"regproc\", quote_style: None, span: Span(Location(1,458)..Location(1,465)) })]), [])"), NotImplemented("Unsupported SQL type Custom(ObjectName([Identifier(Ident { value: \"regproc\", quote_style: None, span: Span(Location(1,953)..Location(1,960)) })]), [])"), NotImplemented("Unsupported SQL type Custom(ObjectName([Identifier(Ident { value: \"regproc\", quote_style: None, span: Span(Location(1,1118)..Location(1,1125)) })]), [])"), NotImplemented("Unsupported SQL type Custom(ObjectName([Identifier(Ident { value: \"regproc\", quote_style: None, span: Span(Location(1,1351)..Location(1,1358)) })]), [])"), NotImplemented("Unsupported SQL type Custom(ObjectName([Identifier(Ident { value: \"regproc\", quote_style: None, span: Span(Location(1,1646)..Location(1,1653)) })]), [])"), NotImplemented("Unsupported SQL type Custom(ObjectName([Identifier(Ident { value: \"regproc\", quote_style: None, span: Span(Location(1,1805)..Location(1,1812)) })]), [])"), NotImplemented("Unsupported SQL type Custom(ObjectName([Identifier(Ident { value: \"regproc\", quote_style: None, span: Span(Location(1,1978)..Location(1,1985)) })]), [])")])
