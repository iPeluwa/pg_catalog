# Task 101
exec_error query: "select T.tgrelid as table_id,\n       T.oid as trigger_id,\n       T.xmin as trigger_state_number,\n       T.tgname as trigger_name,\n       T.tgfoid as function_id,\n       pg_catalog.encode(T.tgargs, 'escape') as function_args,\n       T.tgtype as bits,\n       T.tgdeferrable as is_deferrable,\n       T.tginitdeferred as is_init_deferred,\n       T.tgenabled as trigger_fire_mode,\n       T.tgattr as columns,\n       T.tgconstraint != 0 as is_constraint,\n       T.tgoldtable /* null */ as old_table_name,\n       T.tgnewtable /* null */ as new_table_name,\n       pg_catalog.pg_get_triggerdef(T.oid, true) as source_code\nfrom pg_catalog.pg_trigger T\njoin pg_catalog.pg_class TAB on TAB.oid = T.tgrelid and TAB.relnamespace = $1::oid\nwhere true\n  --  and TAB.relname in ( :[*f_names] )\n  and pg_catalog.age(T.xmin) <= coalesce(nullif(greatest(pg_catalog.age($2::varchar::xid), -1), -1), 2147483647)\n  and not T.tgisinternal"
exec_error params: Some([Some(b"\0\0\0\0\0\0\x08\x98"), Some(b"\0\0\0\0\0\0\0\0")])
exec_error error: Collection([Diagnostic(Diagnostic { kind: Error, message: "Invalid function 'pg_catalog.encode'", span: Some(Span(Location(1,135)..Location(1,145))), notes: [DiagnosticNote { message: "Possible function 'pg_catalog.age'", span: None }], helps: [] }, Plan("Invalid function 'pg_catalog.encode'.\nDid you mean 'pg_catalog.age'?")), Diagnostic(Diagnostic { kind: Error, message: "Invalid function 'pg_catalog.pg_get_triggerdef'", span: Some(Span(Location(1,437)..Location(1,447))), notes: [DiagnosticNote { message: "Possible function 'pg_catalog.pg_get_indexdef'", span: None }], helps: [] }, Plan("Invalid function 'pg_catalog.pg_get_triggerdef'.\nDid you mean 'pg_catalog.pg_get_indexdef'?"))])
# Task 101: Done
Implemented placeholders for `encode` and `pg_get_triggerdef` returning `NULL`. Registered them with the server and added tests.
# Task 102
exec_error query: "with A as (\n  select oid as table_id, pg_catalog.upper(relkind) as table_kind\n  from pg_catalog.pg_class\n  where relnamespace = $1::oid\n    and relkind in ('r', 'm', 'v', 'f', 'p')\n--  and relname in ( :[*f_names] )\n)\nselect table_kind,\n       table_id,\n       R.oid as rule_id,\n       pg_catalog.pg_get_ruledef(R.oid, true) as source_text\nfrom A join pg_catalog.pg_rewrite R\n        on A.table_id = R.ev_class\nwhere R.rulename != '_RETURN'::name\n  and pg_catalog.age(R.xmin) <= coalesce(nullif(greatest(pg_catalog.age($2::varchar::xid), -1), -1), 2147483647)"
exec_error params: Some([Some(b"\0\0\0\0\0\0\x08\x98"), Some(b"\0\0\0\0\0\0\0\x02")])
exec_error error: Diagnostic(Diagnostic { kind: Error, message: "Invalid function 'pg_catalog.upper'", span: Some(Span(Location(1,36)..Location(1,46))), notes: [DiagnosticNote { message: "Possible function 'pg_catalog.age'", span: None }], helps: [] }, Plan("Invalid function 'pg_catalog.upper'.\nDid you mean 'pg_catalog.age'?"))
# Task 102: Done
Added `upper` implementation and a stub for `pg_get_ruledef`. Both are registered and covered by tests.
